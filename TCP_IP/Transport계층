애플리케이션에 데이터 전달하는 계층이다.
포트번호로 애플리케이션을 구분함 ( 80은 HTTP )

*포트번호 (0~65535)
well-known / registered / dynamic 세개로 구분

well-known : 서버프로그램이 수신대기할때 사용 (0~1023)
registred : 벤더가 할당받아 사용 (1024~49151)
dynamic : 클라이언트프로그램이 사용 (49152~65535)

클라이언트가 사용하는 포트번호는 다이나믹포트영역에서 그때그때 랜덤 부여

클라이언트 - 서버접속
1.클라이언트 웹브라우져는 다이나믹에서 할당
2. 웹서버는 http는 80 사용
3. 클라이언트에서 80에 접속요청보냄
4. 웹서버가 접속 허용

TCP의 데이터 전달법
  - 정확한 데이터 전달이 필요할 때 TCP 사용
  - 데이터를 일단 세그먼트단위로 분할한다
  - 그 다음 TCP 헤더를 붙인다
  - 서버에서 클라이언트에게 데이터를 보내고, 클라이언트는 얼마만큼의 데이터를 받았는지 수신확인 응답
  - 데이터 보낸양과 받은양이 다르면 재전송
 
 TCP 헤더
  - 세그먼트
  - 송신지 포트번호 , 수신지 포트번호, 일련번호, 확인응답번호, 컨트롤 비트 등등으로 구성
 
컨트롤비트
  - 현재 통신상태를 나타낸다
  - 여러 플래그를 가지며 각각 ON/OFF를 표현함
  
커넥션 연결
  - 3단계로 진행된다 (3방향 핸드셰이크)
  
  커넥션 연결 (통신개시)
  1.클라이언트에서 SYN-ON 보냄
  2.서버에서 ACK-ON 보냄 (데이터 잘 도착했다는 응답)
  3. 클라이언트도 ACK-ON 다시 보냄
  
  커넥션 종료
  1. 클라이언트에서 FIN-ON 보냄
  2. 서버에서 ACK-ON 보냄
  3. 클라이언트에서ACK-ON 보냄
  

데이터전송의 일련번호
  -커넥션 맺을때마다 일련번호 1씩 증가
  - 데이터 전송 시 전송한 데이터의 바이트 수 만큼 일련번호에 더해진다
  - 수신후 에는 수신한 데이터의 바이트 수 만큼 확인응답번호에 더한다

송신측에서는 일정시간이 지나도 응답이 안오면 송신실패로 간주, 정상응답 받은 이후부터 재전송
응답 이후 데이터를 계속 보내는건 느리다 연속된 데이터는 몰아서 보내고 응답도 몰아서 받자

버퍼는 한번에 받을 수 있는 데이터의 크키이다. TCP헤더의 윈도우사이즈에 버퍼크기를 설정하면 송신쪽에서 그정도로 보냄
버퍼를 설정해놓아도 수신측에서 버퍼처리속도가 느리면 데이터 들어오는 속도도 조절해야함 -> 수시로 윈도우사이즈를 설정해서 "흐름제어"를 한다
버퍼가 가득차면 윈도우사이즈가 0이 된다. 데이터 전송은 멈춤, 송신측에서는 언제 전송 재개할지 알기위해 윈도우 프로브를 보냄. 수신측은 윈도우사이즈의 응답으로
다시 윈도우사이즈를 보내고 서버는 이를 확인 후 전송재개여부 결정

버퍼에 빈 공간이 있어도 네트워크가 혼잡하면 통신속도 낮춰야함. 이때 사용하는 플래그는 ECE ,CWR
ECE - 버퍼는 여유 있으나 통신경로 혼잡 (얘는 IP헤더안에 있다 - 인터넷계층)

SACK - 재전송 할 경우 다 보내지 않고 누락된 패킷만 재전송하는 선택적확인응답법 (송수신측 모두 지원해야 사용가능)


UDP
다른처리없이 전송만 해서 속도가 빠르다
UDP 헤더는 간단함 - 송수신지 포트번호, 패킷길이, 체크섬(데이터훼손확인여부)
속도도 빠르고 데이터전송도 신뢰성 필요하면 애플리케이션계층에서 흐름제어, 혼잡제어 구현해서 사용한다
UDP는 하나의 패킷을 여러 수신지에 전달하는 브로드캐스트, 멀티캐스트기능이 있다 (TCP는 없음)
